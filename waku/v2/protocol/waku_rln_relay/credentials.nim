when (NimMajor, NimMinor) < (1, 4):
  {.push raises: [Defect].}
else:
  {.push raises: [].}

import 
  chronicles, options, chronos, stint, json, strutils,
  stew/byteutils,
  std/os,
  ../../utils/keyfile,
  ../../utils/time,
  ./constants,
  ./protocol_metrics

type
  IdentityTrapdoor* = array[32, byte]
  IdentityNullifier* = array[32, byte]
  # identity key as defined in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IdentitySecretHash* = array[32, byte]
  # hash of identity key as defined ed in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IDCommitment* = array[32, byte]

type IdentityCredential* = object
  idTrapdoor*: IdentityTrapdoor
  idNullifier*: IdentityNullifier
  ## user's identity key (a secret key) which is selected randomly
  ## see details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idSecretHash*: IdentitySecretHash
  # hash of user's identity key generated by
  # Poseidon hash function implemented in rln lib
  # more details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idCommitment*: IDCommitment

type MembershipIndex* = uint

type MembershipGroup* = object
  chainId*: string
  contract*: string
  treeIndex*: MembershipIndex

type MembershipCredentials* = object
   identityCredential*: IdentityCredential
   membershipGroups*: seq[MembershipGroup]

type AppKeystore* = object
  application*: string
  appIdentifier*: string
  credentials*: seq[MembershipCredentials]
  version*: string

type
  AppKeystoreError = enum
    OsError               = "keystore error: OS specific error"
    IoError               = "keystore error: IO specific error"
    JsonKeyError          = "keystore error: fields not present in JSON"
    JsonError             = "keystore error: JSON encoder/decoder error"
    KeystoreDoesNotExist  = "keystore error: file does not exist"
    CreateKeyfileError    = "Error while creating keyfile for credentials"
    SaveKeyfileError      = "Error while saving keyfile for credentials"
    ReadKeyfileError      = "Error while reading keyfile for credentials"

type KeystoreResult[T] = Result[T, AppKeystoreError]


proc loadAppKeystore*(path: string,
                      application: string,
                      appIdentifier: string,
                      version: string): KeystoreResult[JsonNode] =

  ## Load and decode JSON keystore from pathname
  var data: JsonNode
  var matchingAppKeystore: JsonNode

  if fileExists(path) == false:
    return err(KeystoreDoesNotExist)

  # Note that lines strips the ending newline, if present
  try:
    for keystore in lines(path):

      # We skip empty lines
      if keystore.len == 0:
        continue
      # We skip all lines that doesn't seem to define a json
      if keystore[0] != '{' or keystore[^1] != '}':
        continue

      try:
        data = json.parseJson(keystore)
        # We load the first json found matching the app parameters
        if data["application"].getStr() == application and 
           data["appIdentifier"].getStr() == appIdentifier and 
           data["version"].getStr() == version:
          matchingAppKeystore = data
          break
      except KeyError:
        return err(JsonKeyError)
      except JsonParsingError:
        return err(JsonError)
      except ValueError:
        return err(JsonError)
      except OSError:
        return err(OsError)
      except Exception: #parseJson raises Exception
        return err(OsError)

  except IOError:
    return err(IoError)

  return ok(matchingAppKeystore)



proc writeMembershipCredentials*(path: string,
                                 credentials: seq[MembershipCredentials],
                                 password: string,
                                 application: string,
                                 appIdentifier: string,
                                 version: string): KeystoreResult[void] =

  # if keystore exists we load it


  info "Storing AppKeystore"
  var jsonString: string
  jsonString.toUgly(%credentials)
  let keyfile = createKeyFileJson(toBytes(jsonString), password)

  if keyfile.isErr():
    return err(CreateKeyfileError)
  if saveKeyFile(path, keyfile.get()).isErr():
    return err(SaveKeyfileError)
  return ok()


proc writeMembershipCredentials*(path: string,
                                 credentials: MembershipCredentials,
                                 password: string): KeystoreResult[void] =
  # Returns RlnRelayResult[void], which indicates the success of the call
  info "Storing RLN credentials"
  var jsonString: string
  jsonString.toUgly(%credentials)
  let keyfile = createKeyFileJson(toBytes(jsonString), password)
  if keyfile.isErr():
    return err(CreateKeyfileError)
  if saveKeyFile(path, keyfile.get()).isErr():
    return err(SaveKeyfileError)
  return ok()

# Attempts decryptions of all keyfiles with the provided password.
# If one or more credentials are successfully decrypted, the max(min(index,number_decrypted),0)-th is returned.
proc readMembershipCredentials*(path: string,
                         password: string,
                         index: int = 0): KeystoreResult[Option[MembershipCredentials]] =
  # Returns CredentialResult[Option[MembershipCredentials]], which indicates the success of the call
  info "Reading RLN credentials"
  # With regards to printing the keys, it is purely for debugging purposes so that the user becomes explicitly aware of the current keys in use when nwaku is started.
  # Note that this is only until the RLN contract being used is the one deployed on Goerli testnet.
  # These prints need to omitted once RLN contract is deployed on Ethereum mainnet and using valuable funds for staking.
  waku_rln_membership_credentials_import_duration_seconds.nanosecondTime:

    try:
      var decodedKeyfiles = loadKeyFiles(path, password)

      if decodedKeyfiles.isOk():
        var decodedRlnCredentials = decodedKeyfiles.get()
        debug "Successfully decrypted keyfiles for the provided password", numberKeyfilesDecrypted=decodedRlnCredentials.len
        # We should return the index-th decrypted credential, but we ensure to not overflow
        let credentialIndex = max(min(index, decodedRlnCredentials.len - 1), 0)
        debug "Picking credential with (adjusted) index", inputIndex=index, adjustedIndex=credentialIndex
        let jsonObject = parseJson(string.fromBytes(decodedRlnCredentials[credentialIndex].get()))
        let deserializedRlnCredentials = to(jsonObject, MembershipCredentials)
        debug "Deserialized RLN credentials", rlnCredentials=deserializedRlnCredentials
        return ok(some(deserializedRlnCredentials))
      else:
        debug "Unable to decrypt RLN credentials with provided password. ", error=decodedKeyfiles.error
        return ok(none(MembershipCredentials))
    except:
      return err(ReadKeyfileError)