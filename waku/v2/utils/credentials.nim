when (NimMajor, NimMinor) < (1, 4):
  {.push raises: [Defect].}
else:
  {.push raises: [].}

import 
  chronicles, options, json, strutils,
  stew/byteutils,
  std/[algorithm, os, sequtils, sets],
  ./keyfile
  
type
  IdentityTrapdoor* = seq[byte] #array[32, byte]
  IdentityNullifier* = seq[byte] #array[32, byte]
  # identity key as defined in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IdentitySecretHash* = seq[byte] #array[32, byte]
  # hash of identity key as defined ed in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IDCommitment* = seq[byte] #array[32, byte]

type IdentityCredential* = object
  idTrapdoor*: IdentityTrapdoor
  idNullifier*: IdentityNullifier
  ## user's identity key (a secret key) which is selected randomly
  ## see details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idSecretHash*: IdentitySecretHash
  # hash of user's identity key generated by
  # Poseidon hash function implemented in rln lib
  # more details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idCommitment*: IDCommitment

type MembershipIndex* = uint

type MembershipContract* = object
  chainId*: string
  address*: string

type MembershipGroup* = object
  membershipContract*: MembershipContract
  treeIndex*: MembershipIndex

type MembershipCredentials* = object
   identityCredential*: IdentityCredential
   membershipGroups*: seq[MembershipGroup]

type AppKeystore* = object
  application*: string
  appIdentifier*: string
  credentials*: seq[MembershipCredentials]
  version*: string

type
  AppKeystoreError = enum
    OsError               = "keystore error: OS specific error"
    IoError               = "keystore error: IO specific error"
    JsonKeyError          = "keystore error: fields not present in JSON"
    JsonError             = "keystore error: JSON encoder/decoder error"
    KeystoreDoesNotExist  = "keystore error: file does not exist"
    CreateKeystoreError   = "Error while creating application keystore"
    LoadKeystoreError     = "Error while loading application keystore"
    CreateKeyfileError    = "Error while creating keyfile for credentials"
    SaveKeyfileError      = "Error while saving keyfile for credentials"
    ReadKeyfileError      = "Error while reading keyfile for credentials"

type KeystoreResult[T] = Result[T, AppKeystoreError]


proc encode*(credential: MembershipCredentials): seq[byte] =
  # TODO: use custom encoding, avoid wordy json
  var stringCredential: string
  # NOTE: toUgly appends to the string, doesn't replace its contents
  stringCredential.toUgly(%credential)
  return toBytes(stringCredential)

proc decode*(encodedCredential: seq[byte]): KeystoreResult[MembershipCredentials] =
  # TODO: use custom decoding, avoid wordy json
  try:
    # we parse the json decrypted keystoreCredential
    let jsonObject = parseJson(string.fromBytes(encodedCredential))
    return ok(to(jsonObject, MembershipCredentials))
  except JsonParsingError:
    return err(JsonError)
  except Exception: #parseJson raises Exception
    return err(OsError)


proc sortMembershipGroup*(a,b: MembershipGroup): int =
  return cmp(a.membershipContract.address, b.membershipContract.address)

proc createAppKeystore*(path: string,
                        application: string,
                        appIdentifier: string,
                        version: string): KeystoreResult[void] =

  let keystore = AppKeystore(application: application,
                             appIdentifier: appIdentifier,
                             credentials: @[],
                             version: version)

  var jsonKeystore: string
  jsonKeystore.toUgly(%keystore)

  var f: File
  if not f.open(path, fmWrite):
    return err(OsError)

  try:
    # To avoid other users/attackers to be able to read keyfiles, we make the file readable/writable only by the running user
    setFilePermissions(path, {fpUserWrite, fpUserRead})
    f.write(jsonKeystore)
    # We store a keystore per line
    f.write("\n")
    ok()
  except CatchableError:
    err(OsError)
  finally:
    f.close()

proc loadAppKeystore*(path: string,
                      application: string,
                      appIdentifier: string,
                      version: string): KeystoreResult[JsonNode] =

  ## Load and decode JSON keystore from pathname
  var data: JsonNode
  var matchingAppKeystore: JsonNode

  # If no keystore exists at path we create a new empty one with passed keystore parameters
  if fileExists(path) == false:
    let newKeystore = createAppKeystore(path, application, appIdentifier, version)
    if newKeystore.isErr():
        return err(CreateKeystoreError)

  try:

    # We read all the file contents
    var f: File
    if not f.open(path, fmRead):
      return err(OsError)
    let fileContents = readAll(f)

    # We iterate over each line (which we expect to correspond to a single keystore json)
    for keystore in fileContents.split('\n'):

      # We skip if read line is empty
      if keystore.len == 0:
        continue
      # We skip all lines that don't seem to define a json
      if not keystore.startsWith("{") or not keystore.endsWith("}"):
        continue

      try:
        # We parse the json
        data = json.parseJson(keystore)

        # We check if parsed json contains the relevant keystore credentials fields and if these are set to the passed parameters 
        # (note that "if" is lazy, so if one of the .contains() fails, the json fields contents will not be checked and no ResultDefect will be raised due to accessing unavailable fields)
        if data.contains("application") and data.contains("appIdentifier") and data.contains("credentials") and data.contains("version") and
           data["application"].getStr() == application and 
           data["appIdentifier"].getStr() == appIdentifier and 
           data["version"].getStr() == version:
          # We return the first json keystore that matches the passed app parameters
          # We assume a unique kesytore with such parameters is present in the file
          matchingAppKeystore = data
          break
      # TODO: we might continue rather than return for some of these errors
      except KeyError:
        return err(JsonKeyError)
      except JsonParsingError:
        return err(JsonError)
      except ValueError:
        return err(JsonError)
      except OSError:
        return err(OsError)
      except Exception: #parseJson raises Exception
        return err(OsError)

  except IOError:
    return err(IoError)

  return ok(matchingAppKeystore)


proc addMembershipCredentials*(path: string,
                               credentials: seq[MembershipCredentials],
                               password: string,
                               application: string,
                               appIdentifier: string,
                               version: string): KeystoreResult[void] =

  # We load the keystore corresponding to the desired parameters
  # This call ensures that JSON has all required fields
  let jsonKeystoreOpt = loadAppKeystore(path, application, appIdentifier, version)

  if jsonKeystoreOpt.isErr():
    return err(LoadKeystoreError)

  # We load the JSON node corresponding to the app keystore
  var jsonKeystore = jsonKeystoreOpt.get()

  try:

    # We get all credentials in keystore
    var keystoreCredentials = jsonKeystore["credentials"]
    var found: bool

    for membershipCredential in credentials:

      # A flag to tell us if the keystore contains a credential associated to the input identity credential, i.e. membershipCredential
      found = false

      for keystoreCredential in keystoreCredentials.mitems():
        # keystoreCredential is encrypted. We decrypt it
        let decodedKeyfile = decodeKeyFileJson(keystoreCredential, password)
        if decodedKeyfile.isOk():

          # we parse the json decrypted keystoreCredential
          let decodedCredential = decode(decodedKeyfile.get())
          
          if decodedCredential.isOk():
            let keyfileMembershipCredential = decodedCredential.get()

            # We check if the decrypted credential has its identityCredential field equal to the input credential
            if keyfileMembershipCredential.identityCredential == membershipCredential.identityCredential:
              # idCredential is present in keystore. We add the input credential membership group to the one contained in the decrypted keystore credential (we deduplicate groups using sets)
              var allMemberships = toSeq(toHashSet(keyfileMembershipCredential.membershipGroups) + toHashSet(membershipCredential.membershipGroups))

              # We sort membership groups, otherwise we will not have deterministic results in tests
              allMemberships.sort(sortMembershipGroup, Ascending)

              # we define the updated credential with the updated membership sets
              let updatedCredential = MembershipCredentials(identityCredential: keyfileMembershipCredential.identityCredential, membershipGroups: allMemberships)

              # we re-encrypt creating a new keyfile
              let encodedUpdatedCredential = updatedCredential.encode()
              let updatedCredentialKeyfile = createKeyFileJson(encodedUpdatedCredential, password)
              if updatedCredentialKeyfile.isErr():
                return err(CreateKeyfileError)

              # we update the original credential field in keystoreCredentials
              keystoreCredential = updatedCredentialKeyfile.get()
              
              found = true

              # We stop decrypting other credentials in the keystore
              break

      # If no credential in keystore with same input identityCredential value is found, we add it    
      if found == false:

        try:    
          let encodedMembershipCredential = membershipCredential.encode()
          let keyfile = createKeyFileJson(encodedMembershipCredential, password)
          if keyfile.isErr():
            return err(CreateKeyfileError)

          # We add it to the credentials field of the keystore
          jsonKeystore["credentials"].add(keyfile.get())

        except KeyError:
          return err(JsonKeyError)

  except KeyError:
    return err(JsonKeyError)
  except:
    return err(JsonError)

  # We save to disk the keystore.

  # We first backup the current keystore
  if fileExists(path):
    try:
      moveFile(path, path & ".bkp")
    except:
      return err(OsError)
  
  # We save the updated json
  var f: File
  if not f.open(path, fmAppend):
    return err(OsError)
  try:
    # To avoid other users/attackers to be able to read keyfiles, we make the file readable/writable only by the running user
    setFilePermissions(path, {fpUserWrite, fpUserRead})
    f.write($jsonKeystore)
    # We store a keyfile per line
    f.write("\n")
  except CatchableError:
    # We got some OsError writing to disk. We attempt to restore the previous keystore backup
    if fileExists(path & ".bkp"):
      try:
        f.close()
        removeFile(path)
        moveFile(path & ".bkp", path)
      except:
        # Unlucky, we just fail
        return err(OsError)
    return err(OsError)
  finally:
    f.close()

  # The write went fine, so we can remove the backup keystore
  if fileExists(path & ".bkp"):
    try:
      removeFile(path & ".bkp")
    except:
      return err(OsError)

  return ok()


proc filterCredential*(credential: MembershipCredentials,
                       filterIdentityCredentials: seq[IdentityCredential],
                       filterMembershipContracts: seq[MembershipContract]): Option[MembershipCredentials] =
  
  # We filter by identity credentials
  if filterIdentityCredentials.len() != 0:
    if (credential.identityCredential in filterIdentityCredentials) == false:
      return none(MembershipCredentials)

  # We filter by membership groups credentials
  if filterMembershipContracts.len() != 0:
    # Here we keep only groups that match a contract in the filter
    var membershipGroupsIntersection: seq[MembershipGroup] = @[] 
    # We check if we have a group in the input credential matching any contract in the filter
    for membershipGroup in credential.membershipGroups:
      if membershipGroup.membershipContract in filterMembershipContracts:
        membershipGroupsIntersection.add(membershipGroup)

    if membershipGroupsIntersection.len() != 0:
      # If we have a match on some groups, we return the credential with filtered groups
      return some(MembershipCredentials(identityCredential: credential.identityCredential,
                                        membershipGroups: membershipGroupsIntersection))

    else:
      return none(MembershipCredentials)
    
  # We hit this return only if 
  # - filterIdentityCredentials.len() == 0 and filterMembershipContracts.len() == 0 (no filter)
  # - filterIdentityCredentials.len() != 0 and filterMembershipContracts.len() == 0 (filter only on identity credential)
  # Indeed, filterMembershipContracts.len() != 0 will have its exclusive return based on all values of membershipGroupsIntersection.len()
  return some(credential)

proc getMembershipCredentials*(path: string,
                               password: string,
                               filterIdentityCredentials: seq[IdentityCredential] = @[],
                               filterMembershipContracts: seq[MembershipContract] = @[],
                               application: string,
                               appIdentifier: string,
                               version: string): KeystoreResult[seq[MembershipCredentials]] =

  var outputMembershipCredentials: seq[MembershipCredentials] = @[]

  # We load the keystore corresponding to the desired parameters
  # This call ensures that JSON has all required fields
  let jsonKeystoreOpt = loadAppKeystore(path, application, appIdentifier, version)

  if jsonKeystoreOpt.isErr():
    return err(LoadKeystoreError)

  # We load the JSON node corresponding to the app keystore
  var jsonKeystore = jsonKeystoreOpt.get()

  try:

    # We get all credentials in keystore
    var keystoreCredentials = jsonKeystore["credentials"]

    for keystoreCredential in keystoreCredentials.mitems():

      # keystoreCredential is encrypted. We decrypt it
      let decodedKeyfile = decodeKeyFileJson(keystoreCredential, password)
      if decodedKeyfile.isOk():
          # we parse the json decrypted keystoreCredential
          let decodedCredential = decode(decodedKeyfile.get())
          
          if decodedCredential.isOk():
            let keyfileMembershipCredential = decodedCredential.get()
    
            let filteredCredential = filterCredential(keyfileMembershipCredential, filterIdentityCredentials, filterMembershipContracts)
            
            if filteredCredential.isSome():
              outputMembershipCredentials.add(filteredCredential.get())

  except KeyError:
    return err(JsonKeyError)
  except:
    return err(JsonError)

  return ok(outputMembershipCredentials)



proc writeMembershipCredentials*(path: string,
                                 credentials: MembershipCredentials,
                                 password: string): KeystoreResult[void] =
  # Returns RlnRelayResult[void], which indicates the success of the call
  info "Storing RLN credentials"
  var jsonString: string
  jsonString.toUgly(%credentials)
  let keyfile = createKeyFileJson(toBytes(jsonString), password)
  if keyfile.isErr():
    return err(CreateKeyfileError)
  if saveKeyFile(path, keyfile.get()).isErr():
    return err(SaveKeyfileError)
  return ok()

# Attempts decryptions of all keyfiles with the provided password.
# If one or more credentials are successfully decrypted, the max(min(index,number_decrypted),0)-th is returned.
proc readMembershipCredentials*(path: string,
                         password: string,
                         index: int = 0): KeystoreResult[Option[MembershipCredentials]] =
  # Returns CredentialResult[Option[MembershipCredentials]], which indicates the success of the call
  info "Reading RLN credentials"
  # With regards to printing the keys, it is purely for debugging purposes so that the user becomes explicitly aware of the current keys in use when nwaku is started.
  # Note that this is only until the RLN contract being used is the one deployed on Goerli testnet.
  # These prints need to omitted once RLN contract is deployed on Ethereum mainnet and using valuable funds for staking.
  try:
    var decodedKeyfiles = loadKeyFiles(path, password)

    if decodedKeyfiles.isOk():
      var decodedRlnCredentials = decodedKeyfiles.get()
      debug "Successfully decrypted keyfiles for the provided password", numberKeyfilesDecrypted=decodedRlnCredentials.len
      # We should return the index-th decrypted credential, but we ensure to not overflow
      let credentialIndex = max(min(index, decodedRlnCredentials.len - 1), 0)
      debug "Picking credential with (adjusted) index", inputIndex=index, adjustedIndex=credentialIndex
      let jsonObject = parseJson(string.fromBytes(decodedRlnCredentials[credentialIndex].get()))
      let deserializedRlnCredentials = to(jsonObject, MembershipCredentials)
      debug "Deserialized RLN credentials", rlnCredentials=deserializedRlnCredentials
      return ok(some(deserializedRlnCredentials))
    else:
      debug "Unable to decrypt RLN credentials with provided password. ", error=decodedKeyfiles.error
      return ok(none(MembershipCredentials))
  except:
    return err(ReadKeyfileError)